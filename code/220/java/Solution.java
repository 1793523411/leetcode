class Solution {
    private int sz;//桶大小
    
    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {
        if(t < 0)    return false; //绝对值不可能为负
        sz = t + 1;
        Map<Integer, Long> map = new HashMap<>(); //哈希表，桶号映射到值，值用Long防止溢出
        for(int i = 0; i < nums.length; i++)
        {
            int key = getID(nums[i]); //得到桶号
            if(map.containsKey(key)) // 同一个桶，差的绝对值必然满足要求
                return true;
            if(map.containsKey(key - 1) && Math.abs(map.get(key - 1) - nums[i]) <= t) //检查相邻桶
                return true;
            if(map.containsKey(key + 1) && Math.abs(map.get(key + 1) - nums[i]) <= t)
                return true;
            map.put(key, (long)nums[i]); //将该值放入桶中
            if(i >= k)    map.remove(getID(nums[i - k]));//为了始终满足下标的差的绝对值要求
        }
        return false;
    }
    /*计算桶号*/
    private int getID(int num) {
        return (num < 0) ? num / sz - 1 : num / sz; //防止0号桶同时存在正负数干扰判断
    }
}

/**
 *  检查数组中是否有两个数，既满足给定的下标要求，也满足差的要求。

    很自然的想法是，能不能建立一个哈希表，对于数组每个元素让我们查询是否存在另一个元素与之配对（满足上述两个要求）。

    以题目示例3为例，数组nums = [1,5,9,1,5,9]，k = 2，t = 3，下标差的绝对值不能超过2，元素差的绝对值不能超过3.

    不妨先解决下标的问题。
    如果我们每检查3个元素，都把第1个元素删掉，因为对于下一个元素，它和第1个元素的下标差为3不满足要求。如此便可使得每次检查时都不存在超出下标要求的元素。这样就可以满足下标差的绝对值不超过2的要求。

    然后是差的问题，我们要存储已访问元素的什么信息才可以让接下来的元素查询到是否满足差的绝对值要求，这也是构建哈希表的关键。
    假设现在检查元素9，我们想知道是否之前存储了6、7、8、9、10、11、12，因为这些元素都满足差的要求，同时没被删除说明也满足下标的要求。
    对于每个元素，我们都想知道之前是否存储了某一范围的元素，这时不难想到桶。
    运用分块思想，令每个桶只能存储一个范围内的数，当我们想知道是否存在某个范围的数时，就去查询对应的桶，看桶内有没有你想要的即可。

    桶的大小定为t+1，这样同一个桶内的元素必然满足差的要求。
    本题中，我们让0号桶存储0、1、2、3；
    1号桶存储4、5、6、7；
    2号桶存储8、9、10、11；以此类推。

    此后，对于每个元素，我们通过nums[i] / sz得到它的桶号，然后查询该桶是否已经存在元素，存在则返回true；否则，我们还要检查左右相邻的两个桶，因为除了本桶，相邻桶内也会有满足要求的元素，同理若存在即返回true。这个机制使得每个桶最多只会有一个元素。
    即对于每个元素，我们最多检查3个桶，没有找到满足要求的元素则将当前元素加入到对应的桶中。
    最后不要忘了，每检查k+1个元素，要把第1个元素从它的桶中删掉。
    至此，我们的哈希表构建完成，存储的是桶号映射到数这样一个键值对。
 */