# n 个骰子的点数

```
把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。

 

你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。

 

示例 1:

输入: 1
输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]
示例 2:

输入: 2
输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]
 

限制：

1 <= n <= 11
```

## 解法一

```js
var dicesProbability = function (n) {
  if (n < 1) {
    return [];
  }
  const res = [0, 1, 1, 1, 1, 1, 1];
  for (let i = 1; i < n; i++) {
    for (let j = 6 * n; j > 0; j--) {
      res[j] = res
        .slice(Math.max(0, j - 6), j)
        .reduce((acc, cur) => acc + cur, 0);
    }
  }
  return res
    .slice(1)
    .map((num) => num / Math.pow(6, n))
    .filter(Boolean);
};
```

## 解法二

使用动态规划

通过动态规划来解决，已知若是 1 个骰子，则 6 面出现的概率都是一样的，即 1/6
若是两个骰子，则可以在原来 1 个骰子的基础上进行概率计算，已知两个骰子的排列为

```js
1+1
1+2 2+1
1+3 2+2 3+1
1+4 2+3 3+2 4+1
1+5 2+4 3+3 4+2 5+1
1+6 2+5 3+4 4+3 5+2 6+1
2+6 3+5 4+4 5+3 6+2
3+6 4+5 5+4 6+3
4+6 5+5 6+4
5+6 6+5
6+6
```

这里将上面的单个排列看做是 sum = x + y，x 为一个骰子【也可以理解为新的一个】甩出来的点数，y 为前几个骰子甩出来的和，这里由于总的骰子数为 2，因此前几个骰子实际上就是上一个骰子。
其计算公式为 `dp[ sum ] = dp[ sum ] + dp[ y ] \* 1/6`。由于 x 只能甩出 1~6 个数，因此概率肯定是 1/6，因此需要匹配的 dp[ y ]需要乘上 1/6。由此不断叠加得到 n 个骰子甩出来的概率。

```js
var dicesProbability = function (n) {
  let dp = [1 / 6, 1 / 6, 1 / 6, 1 / 6, 1 / 6, 1 / 6];
  for (let i = 2; i <= n; i++) {
    const temp = [];
    for (let j = 1; j <= 6; j++) {
      for (let k = 0; k < dp.length; k++) {
        const sum = k + j - 1;
        temp[sum] = (temp[sum] || 0) + (dp[k] * 1) / 6;
      }
    }
    dp = temp;
  }
  return dp;
};
```
