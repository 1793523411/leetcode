## 队列

+ 使用list并调用内置方法，进行入队出队操作，指针指向队尾，入队调用add，出队指针++，判控比较头指针和list的size
+ 由于普通的队列不能容纳更多的元素，所以引出了循环队列，使用固定大小的数组和两个指针来指示起始位置和结束位置。 目的是重用我们之前提到的被浪费的存储
+ 入队时如果为空，头指针设置成0，然后插入值移动为指针，出队时，若头和尾指向同一位置，重置该队列，由于是循环队列，下标应该加一后对数组的长度求余数，根据头指针是否为-1来判断是否为空，根据 ((tail+1)%size) == head 来判断是否满了
+ 队列可以用在BFS算法中，应用：200，岛屿数量；732,打开密码锁,279，完全平方数
+ 刷题过程中发现了双向BFS，嘤嘤嘤
+ 解决问题时使用list就可以起到队列的作用，比如removeFirst(),addLast(),offer(),poll()

## 栈

+ 栈的实现比队列简单，是需要使用一个list然后不需要设置指针，用get，和add，以及，remove即可
+ java还提供了内置的栈库，就很方便,解决问题时，使用内置的就好，不要重复造轮子
+ 栈解决的问题：最小栈，有效括号，每日温度，逆波兰，（忘了给题号，···）
+ 使用栈进行DFS，但找到的不是最短路径
+ DFS解决的问题：200，岛屿数量；133，克隆图；494，目标和


## 动态规划解决的问题

+ 出了新手村再来搞
+ 279，494

## 数组

+ 读取数组中的元素，是通过访问索引的方式来读取的，索引一般从 0 开始，假如我们想要访问索引为 2 处的元素 "D" 时，计算机会进行以下计算：
  + 找到该数组的索引 0 的内存地址： 2008；
  + 将内存地址加上索引值，作为目标元素的地址，即 2008 + 2 = 2010，对应的元素为 "D"，这时便找到了目标元素。
+ 我们知道，计算内存地址这个过程是很快的，而我们一旦知道了内存地址就可以立即访问到该元素，因此它的时间复杂度是常数级别，为 O(1)
+ 数组读取，查找，插入删除的时间复杂度
+ 数组解决的问题：寻找数组中心索引，搜索插入位置，合并
+ 类似一维数组，对于一个二维数组 A = [[1, 2, 3, 4],[2, 4, 5, 6],[1, 4, 6, 8]]，计算机同样会在内存中申请一段 连续 的空间，并记录第一行数组的索引位置，即 A[0][0] 的内存地址，注意，实际数组中的元素由于类型的不同会占用不同的字节数，因此每个方格地址之间的差值可能不为 1。实际题目中，往往使用二维数组处理矩阵类相关问题，包括矩阵旋转、对角线遍历，以及对子矩阵的操作等

