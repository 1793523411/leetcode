## 队列

- 使用 list 并调用内置方法，进行入队出队操作，指针指向队尾，入队调用 add，出队指针++，判控比较头指针和 list 的 size
- 由于普通的队列不能容纳更多的元素，所以引出了循环队列，使用固定大小的数组和两个指针来指示起始位置和结束位置。 目的是重用我们之前提到的被浪费的存储
- 入队时如果为空，头指针设置成 0，然后插入值移动为指针，出队时，若头和尾指向同一位置，重置该队列，由于是循环队列，下标应该加一后对数组的长度求余数，根据头指针是否为-1 来判断是否为空，根据 ((tail+1)%size) == head 来判断是否满了
- 队列可以用在 BFS 算法中，应用：200，岛屿数量；732,打开密码锁,279，完全平方数
- 刷题过程中发现了双向 BFS，嘤嘤嘤
- 解决问题时使用 list 就可以起到队列的作用，比如 removeFirst(),addLast(),offer(),poll()

## 栈

- 栈的实现比队列简单，是需要使用一个 list 然后不需要设置指针，用 get，和 add，以及，remove 即可
- java 还提供了内置的栈库，就很方便,解决问题时，使用内置的就好，不要重复造轮子
- 栈解决的问题：最小栈，有效括号，每日温度，逆波兰，（忘了给题号，···）
- 使用栈进行 DFS，但找到的不是最短路径
- DFS 解决的问题：200，岛屿数量；133，克隆图；494，目标和

## 动态规划解决的问题

- 出了新手村再来搞
- 279，494

## 数组与字符串

- 读取数组中的元素，是通过访问索引的方式来读取的，索引一般从 0 开始，假如我们想要访问索引为 2 处的元素 "D" 时，计算机会进行以下计算：
  - 找到该数组的索引 0 的内存地址： 2008；
  - 将内存地址加上索引值，作为目标元素的地址，即 2008 + 2 = 2010，对应的元素为 "D"，这时便找到了目标元素。
- 我们知道，计算内存地址这个过程是很快的，而我们一旦知道了内存地址就可以立即访问到该元素，因此它的时间复杂度是常数级别，为 O(1)
- 数组读取，查找，插入删除的时间复杂度
- 数组解决的问题：寻找数组中心索引，搜索插入位置，合并
- 类似一维数组，对于一个二维数组 A = [[1, 2, 3, 4],[2, 4, 5, 6],[1, 4, 6, 8]]，计算机同样会在内存中申请一段 连续 的空间，并记录第一行数组的索引位置，即 A[0][0] 的内存地址，注意，实际数组中的元素由于类型的不同会占用不同的字节数，因此每个方格地址之间的差值可能不为 1。实际题目中，往往使用二维数组处理矩阵类相关问题，包括矩阵旋转、对角线遍历，以及对子矩阵的操作等
- 字符串的基本操作对象通常是字符串整体或者其子串，字符串操作比其他数据类型更复杂（例如比较、连接操作）
- 字符串比较
- 我们可以用 “==” 来比较两个字符串吗？这取决于我们使用的语言是否支持运算符重载
- 如果答案是 yes （例如 C++、Python）。我们可以使用 == 来比较两个字符串；
- 如果答案是 no （例如 Java），我们可能无法使用 == 来比较两个字符串。当我们使用 == 时，它实际上会比较这两个对象是否是同一个对象
- 字符串连接
- 对于不同的编程语言中，字符串可能是可变的，也可能是不可变的。不可变意味着一旦字符串被初始化，你就无法改变它的内容
- 在某些语言（如 C ++）中，字符串是可变的。 也就是说，你可以像在数组中那样修改字符串。我们发现在 C++ 中，进行字符串连接并没有明显的性能影响。
- 在其他一些语言（如 Java、Python，js）中，字符串是不可变的，显然，不可变字符串无法被修改。哪怕你只是想修改其中的一个字符，也必须创建一个新的字符串
- 对于 Java 来说，由于字符串是不可变的，因此在连接时首先为新字符串分配足够的空间，复制旧字符串中的内容并附加到新字符串。因此，总时间复杂度将是：`5+5×2+5×3+…+5×n=5×(1+2+3+…+n)=5×n×(n+1)/2 即 O(N2)O(N^2)O(N2)。`
- 针对 Java 中出现的此问题，提供了以下解决方案：
  - 如果你确实希望你的字符串是可变的，则可以使用 `toCharArray` 将其转换为字符数组。
  - 如果你经常必须连接字符串，最好使用一些其他的数据结构，如 `StringBuilder` 。
  - KMP 算法 28 题 两种思路：1.有限自动机，2.next
  - 如何的得到 next 数组：公共前后缀问题
  - Knuth–Morris–Pratt（KMP）算法是一种改进的字符串匹配算法，它的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。它的时间复杂度是 O(m+n)

Kmp 算法参考代码

```c++
int match (char* P, char* S){ // KMP 算法
    int* next = buildNext(P); // 构造 next 表
    int m = (int) strlen (S), i = 0; // 文本串指针
    int n = (int) strlen(P), j = 0; //模式串指针
    while (j < n && i < m) // 自左向右逐个比对字符
        if (0 > j || S[i] == P[j]) // 若匹配，或 P 已移除最左侧
            {i++; j++} // 则转到下一字符
        else
            j = next[j]; // 模式串右移（注意：文本串不用回退）
    delete [] next; // 释放 next 表
    return i - j;
}

int* buildNext(char* P) { // 构造模式串 P 的 next 表
    size_t m = strlen(P), j = 0; // “主”串指针
    int* N = new int[m]; // next 表
    int  t = N[0] = -1; // 模式串指针
    while (j < m - 1)
        if ( 0 > t || P[j] == P[t]){ // 匹配
            j++; t++;
            N[j] = t; // 此句可改进为 N[j] = (P[j] != P[t] ? t : N[t]);
        }else // 失配
        t = N[t];
    return N;

}
```

+ 双指针技巧：从两端向中间迭代数组，经常在排序数组中使用
+ 比如反转数组中的元素，经典双指针问题，
+ 双指针的方法可以相同也可以不同，上面做的都是反方向的双指针，接下来该同方向的双指针了，即快慢指针，明天开启这一篇章
+ 解决这类问题的关键是: 确定两个指针的移动策略。
+ 与前一个场景类似，你有时可能需要在使用双指针技巧之前对数组进行排序，也可能需要运用贪心法则来决定你的运动策略

快慢指针实例：给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度
```python
def removeElement(self, nums: List[int], val: int) -> int:
    slow = 0
    n = len(nums)
    for fast in range(n):
        if nums[fast] != val:
            nums[slow] = nums[fast]
            slow += 1
    return slow
```
